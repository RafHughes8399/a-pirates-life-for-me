-> island texturing 
-> the sky 
-> camera rotate clamping 
-> octree update

-> sky and camera
-> sky is 3 planes, draw first before the rest of the world
-> bound the camera movement in all directions (left, right up, down)

-> octree entity position updating from movement    
-> change update to return a value 


Monday the 1st
sky is done 

let's focus on the island texturing issues (done)
and then camera target and movement clamping (done)
    -> couple of things 


after entity update status return code (think like HTTP)
    -> one for moved
    -> one for dead
    -> one for default

then octree entity management based on update return code
    -> the main idea is repositioning objects after they move
    -> first check if an object has moved
    -> tag it, and reinsert it 
        ideas for reinsertion:
            -> simply remove, and recall insert at the root of the tree
            -> otherwise, first check if in or out of the current node
            -> if still in the same node, no need to remove and reinsert
            -> or instead of going all the way to the top of the tree, find the 
            "highest" possible parent and then reinsert from there

            -> ok let's do a bit of both
                -> if an object moved, check if it still is contained 
                by the current node
                -> if not, remove it and then reproccess it
                -> when reproccessing, find the "highest" possible parent
                for the current entity, and then reinsert from there, instead of always
                going from the root
            -> 

then collision and hitboxes
    -> do basic collision interactions with just the bounding boxes
    -> then more intricate, and accurate hitboxes


    i know how to identify collisions or rather interactions but i dont know how to process them
    i'm trying to avoid the is instance of thing; that is repetitive and naive 

    ideas:
        -> 
        -> define interactions like events, so there is an interaction superclass and the subclasses define the specific interactions in the 
        game and how to handle them (i.e )
            -> but the thing is, all these really change is overloading the main interaction process method based on the interaction
            -> and creating the interaction would still involve some form of instance of 

        -> i think the interaction behaviour has to come from the entity itself ?
        -> an interaction can be considered as one entity interacting with another, i.e the ocean interacts with the ship, the ship interacts with the island
        -> it is one entity that "drives" the interaction and one that "recieves" it, like this_entity.interacts_with(other_entity)
        -> i think simplifying to static and moveable is a good idea, it simplifies the number of cases  
            -> regardless of the static object the ship interacts with, its going to be the same underlying idea of the 
                ship's movement being blocked, or altered, all that changes is the force / mass / density / etc. of the specific entity
            -> similar with moveable logic
    
        -> those interactions can then create events within the game (thinking forward to player interact key prompts)
        -> apply the optimisation specified in the blog post to avoid redundant checks


    the process for checking collisions is as follows
        -> for each collision from the parent check against the objects in the current node 
        -> then duplicate the list of objects
        -> iterate while the dup list is not empty
            -> then loop through the list
                -> check if the object is itself

        -> should objects have a stationary flag ? 

    hitboxes don't complicate much, it just adds another step during the identification of a collision

-> ok interaction record
-> holds references to the two entities
-> processing the interaction calls a.interact(b)
-> the octree identifies interactions 
-> after updating then the game processing the interactions
-> an interaction rectod is creating through and event that is 
made when 

so octree identifies interaction -> calls event to create interaction record
-> the list of interactions is processed each frame bu the game

-> change from ref wrapper to raw ptr, ref wrapper is uncessary

-> the interaction is identified
-> message to the interaction list to create an interaction 


-> look at std for each or std transform 
and object factories and builder



so let's consider interaction processing for a minute
-> do i have to define it both ways
-> you don't have to worry about double interactions 

if you can define a static entity and a moveable entity then 
maybe a static and moveable collision strategy (oooo pattern w)
the static collision strategy defines how the object would interact with moving objects as two static objects cannot interact
the movable collision strategy would define how the object interacts with moving and static objects 
this still requires some form of discerning between static and moveable objects, and doesn't solve the probelm of unique 
interaction behaviours like for ocean 


otherwise, you define a static_entity and a moveable_enity, maybe also a special one like interactable_entity 
then provide some default behaviour which is overriden if necessary for sub_entities, like ocean 

i like this idea. however,
is it 
        entity
    /           \
static          moveable

in this case, entity would be an abstract class and static would provide some base behaviour 
otherwise it could be 
        static_entity
            |
            moveable_enity
but a moveable entity is not a static entity so the inheritance structure makes less sense from like a higher level design perspective
but static and moveable entities are entities, ya dig 

-> ok so set up static entity
-> define the interaction behaviours
-> test them one by one 

ones to do:
moveable <-> static
moveable <-> moveable

ocean -> ship

ocean -> terrain  ?? ? ? ? ? ? ? ? ? ? ?? ? ? ? ? ?? ? ? ? ? ? ? ?
// does nothing for now
ship <-> terrain

your main two at this moment in time are the ocean -> ship
and ship <-> terrain

-> clean up TODOs and print logs
-> clone method to preserve tree copying



ok i need to consider the maths i bit better and what actually needs to happen
calcualte the buoyant force, 
update the position, bounding box and the camera



the flow of operations must be considered

I think the changing of the position should remain in the update class and somehow the 
ocean interaction should modify a value that is then proccessed during that update, 
because the update already handles the changing of the camera and bounding boxes
so reconsider that

really what it does is change the velocity 


let it affect accel not veloc. Accel is reset after updating the position
then the ship can separately handle the chanign of the camera and bounding box
then UI and Debugger
hitboxes for more precise collision
then object factory to create stuff 
then land exploration (interactables) and island decoration 
then fishing points 
then NPCs and quests


Hitboxes:

User Interface:
    -> for now, the hud
    -> there is a ship hud and a player hud, they differ in the elements drawn
    -> perhaps a state pattern ? 

-> the hud is comprised of hud elements (mini map, player status, etc )
-> hud elements consist of a sprite sheet with animations
-> they are Texture2D and a Rectangle for the frame
-> there is a ship hud and a player hud which depend on the state of the player, updated based on an event
-> a game has a hud so it can be rendered on the screen 


-> hud with a list of elements, 
-> hud element consists of a textured and an animation, use the code you wrote previously
-> the hud represents the information from the player by listening to the appropraite events
-> the player and ship hud logic are the same ish, they just differ by their contents and what they listen to
-> so it is a strategy thing 




-> a sprite has a sprite sheet, and a sprite animation
-> sprite is drawn at the rectangle of the animation
-> the animation handles the current position of the rectangle
-> the sprite handles the sheet and the rectangle



TOOD
-> figure out the template stuff, start working on it ig
-> hud building
-> hud art 
-> hitboxes and more accurate interaction detection



HUD:
-> include in cmake (post event, pre game, animation, sprite, hud ) x 
-> incorporate into player class x 
-> build the huds 
    -> ship hud : map, compass, anchor, sail
    -> pirate : map, compass, health
-> draw the elements
-> setup event templates
-> establish event listening
-> define the hud building functions overrides
so a hud element is templated for an event type
that determines what event handler it has and what event it listens for
you could pair an event id to a on event function using a map perhaps ? 

-> make the id on_event function map
-> compile and test 
-> start building the hud for the ship


ok compiles
-> need to setup event map for the Interface
-> need to setup deep copying semantics (element cloning, maybe event cloning too ? )